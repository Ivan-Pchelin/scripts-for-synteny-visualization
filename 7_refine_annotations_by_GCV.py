'''
The script creates subsets of annotations according to
GC content in CDSes. Use GC_content_values_all_seqs.txt
generated by global_GC_content.py to calculate quartiles in R

2022-02-14 by Ivan Pchelin
'''
#############################################################
#############################################################

my_dataset = 'Saphexavirus_19'

# the values generated by quantile() function in R
my_quartiles = {'Q1':[0.2429379,0.3632184],
                'Q2':[0.3632184,0.3950000],
                'Q3':[0.3950000,0.4133333],
                'Q4':[0.4133333,0.5566343]}

#############################################################
#############################################################

import glob
import os
import pathlib
import re
import shutil
import sys

print('\nThe interquartile boundaries for', my_dataset, 'were set to', my_quartiles, end='')
print('. Please amend the values within the code if necessary.')


# This part creates a dictionary with CDS names and GC values
GC_content_values = dict()

my_path = os.getcwd()
cds_files = glob.glob(my_path + '/**/*.cds', recursive=True)

for f in cds_files:
    with open (f) as inf:
        allseqs = []
        rawlines = inf.readlines()
        lines = []
        applicant = ''
        letts = ''
        d = 0
        for g in rawlines:
            if re.findall(r'\w', g):
                if '>' in g:
                    if d != 0:
                        allseqs.append(applicant.strip())
                        allseqs.append(letts)
                        letts = ''
                    applicant = g
                    d += 1
                else:
                    letts += g.strip()
        allseqs.append(applicant.strip())
        allseqs.append(letts)

        runner = 0                    
        while runner < len(allseqs):
            if allseqs[runner].startswith('>'):
                GC_content = len(re.findall(r'[GC]', allseqs[runner+1].strip()))/len(allseqs[runner+1].strip())
                GC_content_values[re.findall(r'\S+', allseqs[runner])[0][5:]] = GC_content
            runner += 2

# This part re-writes the CDS and PEP annotations
files = glob.glob(my_path + '/**/*.*', recursive=True)

for quartile in my_quartiles:
    os.mkdir(quartile)
    for f in files:
        if f.endswith('cds') or f.endswith('pep'):
            with open (f) as inf:
                allseqs = []
                rawlines = inf.readlines()
            try:
                os.mkdir(quartile + '/' + os.path.basename(f)[:-15])
            except:
                pass
            with open (quartile + '/' + os.path.basename(f)[:-15] + '/' + os.path.basename(f), 'w') as ouf:
                lines = []
                applicant = ''
                letts = ''
                d = 0
                for g in rawlines:
                    if re.findall(r'\w', g):
                        if '>' in g:
                            if d != 0:
                                allseqs.append(applicant.strip())
                                allseqs.append(letts)
                                letts = ''
                            applicant = g
                            d += 1
                        else:
                            letts += g.strip()
                allseqs.append(applicant.strip())
                allseqs.append(letts)
                runner = 0                    
                while runner < len(allseqs):
                    if allseqs[runner].startswith('>'):
                        if GC_content_values[re.findall(r'\S+', allseqs[runner])[0][5:]] > my_quartiles[quartile][0]:
                            if GC_content_values[re.findall(r'\S+', allseqs[runner])[0][5:]] <= my_quartiles[quartile][1]:
                                ouf.write(allseqs[runner])
                                ouf.write('\n')
                                ouf.write(allseqs[runner+1])
                                ouf.write('\n')
                    runner += 2


# This part re-writes GFF3 annotations
gff_files = glob.glob(my_path + '/**/*.gff3', recursive=True)
fa_files = glob.glob(my_path + '/**/*.fa', recursive=True)

for quartile in my_quartiles:
    for gff in gff_files:
        
        with open (gff) as inf:
            rawlines = inf.readlines()
        
        outentries = [i for i in rawlines if GC_content_values[re.split(r';', re.findall(r'\S+', i)[8])[0][7:]]
         > my_quartiles[quartile][0] and GC_content_values[re.split(r';', re.findall(r'\S+', i)[8])[0][7:]]
          <= my_quartiles[quartile][1]]

        with open (quartile + '/' + os.path.basename(gff)[:-15] + '/' + os.path.basename(gff), 'w') as ouf:
            for i in outentries:
                ouf.write(i)
        # Copy a corresponding FASTA file to the new location
        for f in fa_files:
            if os.path.basename(gff)[:-15] in f:
                shutil.copyfile(f, quartile + '/' + os.path.basename(gff)[:-16] + 
                    '/' + os.path.basename(gff)[:-16] + '.genome.fa')